#!/usr/bin/ruby
# TODO: -w

# TODO: plotting

require 'onlinestatus'
exit unless OnlineStatus.online?

# TODO: tfuj
require_relative 'btckit/bank.rb'
require_relative 'btckit/config.rb'

require_relative 'lib/finance/homebank'
require_relative 'lib/finance/iks_portfolio'
require_relative 'lib/finance/stocks'
require 'terminal-table'
require 'pathname'
require 'csv'
require 'parallel'

LOG_PATH = "~/misc/net-worth.csv"

mode = :report
until ARGV.empty?
	case ARGV.shift
	when "--log" then mode = :log
	when "--report" then mode = :report
	when "--raw_total" then mode = :raw_total
	else die "Usage: net-worth-keeper [--report] [--log] [--raw_total]"
	end
end

def die(*args)
	STDERR.puts(*args) unless args.empty?
	exit 1
end

btckit_config = BtcKit::Config.new
@bank = BtcKit::Bank.new(btckit_config.bank_filename)

# Look out: the order matters
assets = [
	{ name: 'Účty a peníze', lambda: -> {
		Prvak::Finance::Homebank::Accounting.load.total_value
	} },
	{ name: 'IKS fondy', lambda: -> {
		Prvak::Finance::IKSPortfolio.load.value
	} },
	{ name: 'Bitcoiny', command: 'btc-wallet-price --raw' },
	{ name: 'Akcie', lambda: -> {
		Prvak::Finance::Stocks::StatusReport.build(usd_to_czk: ->(amount_in_usd) {
			@bank.exchange(amount_in_usd, 'USD', 'CZK').cents
		}).total_value_czk
	} },
	{ name: 'EUR účet', command: 'euro-account' }
]

results =
	Parallel.map(assets) { |asset|
		if asset[:command]
			result = `#{asset[:command]}`.to_f
			if $?.exitstatus != 0
				if mode == :report
					puts "Failed to read asset #{asset[:name]}"
				end

				die
			end

			[asset[:name], result]
		elsif asset[:lambda]
			begin
				[asset[:name], asset[:lambda].call]
			rescue => exception
				puts "Failed to read asset #{asset[:name]}!"
				raise
			end
		else
			raise "Invalid asset #{asset[:name]}"
		end
	}.to_h

unless results.all?
	if mode == :report
		puts "Something failed :("
	end
	die
end

total = results.values.inject(&:+)

case mode
when :report
	table = Terminal::Table.new do |t|
		results.each do |asset_name, value|
			t << [asset_name, "%.2f" % value]
		end
		t << :separator
		t << ["Suma", "%.2f" % total]
	end
	puts table
when :log
	CSV.open(Pathname.new(LOG_PATH).expand_path, "a") do |log|
		log << [
			Time.now.strftime("%Y-%m-%d %H:%M:%S"), Time.now.to_i,
			total
		] + results.values
	end
when :raw_total
	puts "%.2f" % total
end
